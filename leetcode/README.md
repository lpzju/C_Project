# 力扣主题

一些思路：
## 递归
递归的时间复杂度，稍微分析以下，知道是递归的次数*递归时进行的计算次数

举例如下：求正整数x的n次幂，时间复杂度限定在logn，那么需要递归，比如16，那么划分成8次幂，然后做一次运算，8次幂由两个4次幂做一次运算得到，4次幂由两个2次幂得到，这样可以得到时间复杂度为logn的算法
> 那么想要减少递归的时间复杂度，就要尽可能的少调用递归

递归的空间复杂度，为每次递归的空间复杂度*递归深度

1. 两数之和
    > 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。

老实说，我没做出来，第一次做，没有理解leetcode的规范输入输出，直接改了函数定义
9. 回文数 
    > 给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。
回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
例如，121 是回文，而 123 不是。

不断得到末位，然后乘10在加
13. 罗马数字转整数
    > 判断比较多，官方做法是变成判断之后再做加或者减
14. 最长公共前缀
    > 编写一个函数来查找字符串数组中的最长公共前缀。
如果不存在公共前缀，返回空字符串 ""。

找到最小长度的字符串，然后遍历这个字符串，如果有不同的，则停下返回
26. 删除有序数组中的重复项
    > 给定升序数组nums，原地删除重复出现的元素，使得每个元素只出现一次，返回删除后数组的新长度，元素的相对顺序应该保持一致
27. 移除数组元素
    > 给定一个数组nums和一个值al，需要原地将所有值等于val的元素，并返回移除后数组的新长度

这里使用双指针，会从暴力的O(n*n)变为O(n)
34. 排序数组中查找第一个元素和最后一个元素
    > 目前想法就是，找出左边界和右边界，至于简化代码，后面再看
35. 搜索插入位置
    > 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置


69. x的算术平方根
    > 给一个非负整数x，计算并返回x的算术平方根
    

136. 只出现一次的数字 
     > 给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。


283. 移动零 
     > 给定一个数组nums，编写一个函数将所有0移动到数组的末尾，同时保持非零元素的相对顺序

只会双指针，时间复杂度为O(n)
704. 二分查找
     >给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

其实也不难，但是以后遇到这样的问题，想想怎么减小时间复杂度，然后还要想想退出的条件
844. 比较含退格的字符串
     >给定s和t两个字符串，当他们分别被输入到空白的文本编辑器后，如果两者相等，返回true，#代表退格字符

个人思路是额外得到一个新的字符串，然后用strcmp进行比较，官方的更加简洁，使用了函数封装

暂未有更好思路：

904. 水果成篮
     > 题目太长，看例子：fruits = [3,3,3,1,2,1,1,2,3,3,4] ，输出为5，中间的 1 2 1 1 2 为最长的5
     
暂时只会比较繁琐的双指针，后续加上

# 剑指offer 2
72. 求平方根
> 给定一个非负整数x，计算并返回 x 的平方根，即实现 int sqrt(int x) 函数。正数的平方根有两个，只输出其中的正数平方根。如果平方根不是整数，输出只保留整数的部分，小数部分将被舍去。

目前只会用暴力循环到n/2

# 剑指offer
65. 不用加减乘除实现加法
> 依然不会，看了答案勉强会了。核心思想是两个位置控制，基本位+进位，进位同时注意一下需要左移一位，同时使用unsigned，因为int的话，如果超过32位会有问题，而unsigned是会进行取余的
66. 

